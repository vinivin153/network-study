- connect이후 제어가 되돌아 오면 데이터를 송수신 → write 동작
- 프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 자체 송신용 버퍼 메모리에 저장

  - 네트워크의 효율을 위해 어느 정도 저장 후 한번에 보냄
  - OS의 종류나 버전에 따라 기준이 달라짐

- MTU: 한 패킷으로 운반할 수 있는 최대 크기(최대전송단위)
  - 이더넷에서 일반적으로 1500바이트
- MSS: MTU에서 헤더를 뺀 데이터의 최대 크기

  - MSS에 가까이 저장해 송신할 경우 지연 발생
    - 일정 시간이 지나면 보내지도록 타이머가 있음
  - MSS보다 데이터가 큰 경우 데이터의 앞부분 부터 MSS크기 만큼 분할 해 송신

- 패킷을 송신한 후 확인동작
- 시퀀스 번호: 데이터의 조각을 송신할 때 세어둔 번호
  - 1부터 시작하면 공격당할 수 있어 초기값을 연결시에 보내줌
- ACK: 몇번 째 데이터까지 수신했는지 계산해 송신측에 보내줌
  - ACK를 받지 못한 경우 패킷을 재전송

### 송수신 과정

1. 클라이언트에서 서버로 보내는 데이터에 관한 초기 시퀀스 번호를 서버에 통지
2. 서버는 초기값으로 부터 ACK 번호를 산출, 서버에서 클라이언트에 보내는 데이터에 관한 초기 시퀀스 번호와 같이 클라이언트에 전송
3. 클라이언트도 마찬가지로 ACK번호를 산출하여 서버에 반송
4. 송수신 동작이 준비되었으므로 시퀀스 번호와 함께 데이터를 전송

- 타임아웃 값: ACK가 돌아오는 것을 기다리는 시간
  - 너무 짧으면 데이터를 재전송 해야하는 낭비와 데이터 혼잡 악화
  - 너무 길면 지연
  - 일반적으로 ACK가 되돌아 오는 시간을 저장해두고 이에 맞게 동적으로 타임아웃 시간을 변경
- 윈도우 제어: ACK번호를 기다릴 때 아무것도 하지 않는것이 아니라 계속해서 다음 데이터를 보내는 방법
  - 대신 수신측에서 수용가능한 데이터양(윈도우 사이즈)을 확인해서 넘치지 않게 제어
- 효율성을 높이기 위해 ACK번호와 윈도우 통지를 함께 한다
  - 연속된 데이터를 받은 경우 ACK도 연속해서 여러개를 보낼 필요 없이 마지막 ACK만 보내 다음 데이터를 받을 수 있다.
    - 윈도우 통지 역시 마찬가지

### 정리

1. 수신한 데이터 조각과 TCP 헤더의 내용을 조사해 데이터의 누락여부를 확인하고 문제가 없는 경우 ACK 전송
2. 데이터 조각을 버퍼에 일시 보관하고 조각을 연결해 원래의 데이터 상태로 복원이 되면 애플리케이션에 컨네줌
3. 윈도우를 송식측에 통지(이 때 ACK와 합승할 수 있는 경우 합승해서 패킷을 보낸다)
